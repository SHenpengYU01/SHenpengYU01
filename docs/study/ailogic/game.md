# 论辩语义的计算方法

## 基于论证博弈的方法

参照人类辩论时所采用的方式，为了判定某一个论证的状态，一种简单的方法是将判断论证状态的证明过程看作是在两个参与者（支持该论证的正方和反对该论证的反方）之间进行的一次论证博弈。

在博弈的过程中，支持某个论证的正方（PRO）和反对该论证的反方（OPP）通过移动可用的论证来进行博弈。一个博弈以正方移动一个想要进行测试的起始论证 a 开始。
随后，反方和正方**依据与某种语义下相对应的规则**依次移动论证来攻击对手的最新移动论证。
我们把正反双方的一个移动论证序列称为一个**争辩**（dispute）。一般来说，一个参与者可以回溯其对手先前的某个移动论证并重启一个新的争辩。因此，论证博弈的数据结构可以表示为一棵争辩树。在树中，从根结点到每个叶结点的分支代表一个争辩。如果一个参与者赢得所有的争辩，那么我们说它有一个**赢策略**。接下来，我们首先介绍争辩树和赢策略的概念。


### 争辩数和赢策略

!!! info "争辩树"
    设 𝐴𝐹 = ⟨𝐴𝑅, 𝑎𝑡𝑡𝑎𝑐𝑘 𝑠⟩ 是一个论辩框架，𝑎 ∈ 𝐴𝑅 是一个论证。
    由 𝑎 引起的争辩树是一颗由论证标记的树 𝑇，满足：

    - 𝑇 的根节点是 𝑎；
    - 且对于 𝐴𝑅 中所有的论证 𝑏、𝑐：𝑏 是 𝑇 中 𝑐 的一个孩子结点，当且仅当 (𝑏, 𝑐) ∈𝑎𝑡𝑡𝑎𝑐𝑘 𝑠。


!!! info "防御线与赢策略"
    设 𝑝𝑙 是一个论证博弈中的一个参与者（正方或反方）。如果一个争辩的最后移动是 𝑝𝑙，
    而 𝑝𝑙 的对手不能对这个最后移动做出应答，那么我们说 𝑝𝑙 赢得这个争辩。
    如果在一棵争辩树中，一个初始论证为 𝛼 的一个争辩由正方赢得，那么我们把这个争辩称为 𝛼 的一条防御线。
    在一棵争辩树中，如果一个初始论证为 𝛼 的所有争辩均由正方赢得，那么我们说正方拥有一个关于 𝛼 的赢策略。


通常，争辩的无限性是由论证之间循环的攻击关系引起的。在具体的论辩语义下，通过制定博弈规则来规定正方或反方是否可以重复已经使用过的
移动，可以得到无限争辩树的子树，而后者是有限的

!!! info "子争辩与赢策略"
    设 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩ 是一个论辩框架，𝑎 ∈ 𝐴𝑅 是一个论证，𝑇 是由 𝑎 引起的一棵争辩树，𝑇′ 是 𝑇 的一棵子树。

    那么，𝑇′ 是 𝑎 的一个赢策略，当且仅当：

    1. 𝑇′ 中争辩的集合 $𝐷_𝑇′$ 是一个非空的有限集合，使得每个争辩 $𝑑 ∈ 𝐷_𝑇′$ 是有限的，且由正方赢得该争辩；

    2. 对于任意的 𝑑 ∈ 𝐷𝑇′，对于任意的 𝑑′，使得 𝑑′ 是 𝑑 的某个子争辩（一个争辩 𝑑 的子争辩 𝑑′ 是 𝑑 的一个子序列，
    它与 𝑑 开始于同样的初始论证），且 𝑑′ 的最后一

如果正方有一个赢策略，即如果正方能在反方任意移动的情况下都能赢，那么初始论证有一个可证的辩证状态。

### 论辩语义下合法移动函数

!!! info "合法移动函数"
    设 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩ 是一个论辩框架，𝑎 ∈ 𝐴𝑅 是一个论证，𝑇 是由 𝑎 引起的一棵争辩树。

    设 𝐷𝑇 是 𝑇 中所有争辩的集合。通常，一个合法移动函数定义 $𝜙 : 𝐷_𝑇 \rightarrow 2^
    {𝐴𝑅}$。

!!! info "𝜙争辩树与赢策略"
    设 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩ 是一个论辩框架，𝑎 ∈ 𝐴𝑅 是一个论证，𝜙 是一个合法移动函数，
    𝑇是由 𝑎 引起的一棵 𝜙-争辩树，𝑇′ 是 𝑇 的一棵子树。那么，𝑇′ 是 𝑎 的一个赢策略，当且仅当：

    1. 𝑇′ 中争辩的集合 𝐷𝑇′ 是一个非空的有限集合，使得每个争辩 𝑑 ∈ 𝐷𝑇′ 是有限的，且由正方赢得该争辩；
    
    2. 对于任意的 𝑑 ∈ 𝐷𝑇′，对于任意的 𝑑′，使得 𝑑′ 是 𝑑 的某个子争辩，且 𝑑′ 的最后一个移动是由正方提出的一个论证 𝑏，
    那么对于反方向以合法移动（依据 𝜙）的任意攻击 𝑏 的论证 𝑐，存在一个 𝑑′′ ∈ 𝐷𝑇′，使得 $𝑑′ − c_{opp}$ 是 𝑑′′的一个子争辩。

#### 基语义下合法移动函数

!!! info "基语义下的合法移动函数"
    给定一个论辩框架 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩，设 𝑑 是一个争辩，𝑎 是 𝑑 中最后一个论证，PRO(𝑑)是 𝑑 中由正方移动的论证集合。
    基语义 𝑔𝑟 下的合法移动函数 $𝜙_{𝑔𝑟}$ 定义如下：

    - 如果 𝑑 是奇数长度的（下一个移动由 OPP 进行），那么𝜙𝑔𝑟 (𝑑) = {𝑏 | (𝑏, 𝑎) ∈ attacks};
    
    - 如果 𝑑 是偶数长度的（下一个移动由 PRO 进行），那么𝜙𝑔𝑟 (𝑑) = {𝑏 | (𝑏, 𝑎) ∈ attacks, 𝑏 ∉PRO(𝑑)}.

!!! note "定理"
    给定一个有限论辩框架 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩。
    那么，存在一个 𝑎 的 𝜙𝑔𝑟-赢策略 𝑇 使得 𝑇 中由正方移动的论证集合 PRO(𝑇) 是无冲突的，当且仅当 𝑎 在 𝐴𝐹 的基外延中。

#### 轻信优先语义下

!!! info "轻信优先语义下的合法移动函数"
    给定一个论辩框架 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩，设 𝑑 是一个争辩，𝑎 是 𝑑 中最后一个论证，
    PRO(𝑑)是 𝑑 中由正方移动的论证集合，OPP(𝑑) 是 𝑑 中由反方移动的论证集合。
    在轻信优先语义 𝑝𝑟 下的合法移动函数 $\phi_{pr}$ 定义如下：

    - 如果 d 是奇数长度的（下一个移动由OPP进行），那么：
    
    $$
    \phi_{pr}(d) = \{b| (b,a)\in \text{attacks}, b\notin \text{OPP(d)}\}
    $$

    - 如果 d 是偶数长度的（下一个移动由PRO进行），那么：
    
    $$
    \phi_{pr}(d) = \{b| (b,a)\in \text{attacks}, b\notin \text{OPP(d)},(b.b)\notin \text{attacks}\}
    $$

!!! note "定理"
    给定一个有限论辩框架AF=<AF,attacks>。那么，存在一个a 的 $\phi_{pr}-$ 赢策略T使得T中由正方移动的论证集合PRO(T)是无冲突的，当且仅当a在AF的一组可相容外延（因此是AF的一个有限外延）中。



## 基于回答集编程的方法

### 从论辩框架到逻辑程序映射

为了在一个 ASP 求解器中计算一个论辩框架的语义，首先需要将一个论辩框架映射到一个逻辑程序，使得逻辑程序的回答集与原有论辩框架的外延一一对应。目前，有两类主要的映射方法：依赖于论辩框架的映射法和独立于论辩框架的映射法。

#### 基于论辩框架的映射法

Nieves 等人提出的依赖于论辩框架的方法主要计算优先外延。
他们的映射依赖于使用命题公式来表达使得论证的集合成为论辩框架的外延的条件。
映射产生一个析取逻辑程序，该程序定义一个谓词 def，其中 def(𝑎) 可以被读作” 论证 𝑎 被击败”。直觉上，

1. 在一个论辩框架 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩ 的 attacks 中的每个对子 (𝑎, 𝑏) 被映射到一个析取的句子 def(𝑎)∨def(𝑏)←；
2. 对于每个对子 (𝑏, 𝑎) ∈ attacks，引入一个句子 def(𝑎) ← def(𝑐1), ..., def(𝑐𝑘)，𝑘 ≥ 0，
其中 $c_1,\dots,c_k$ 是攻击 𝑏 的 𝑎 的所有“防御者”，即：$(𝑐1, 𝑏),...,(𝑐𝑘, 𝑏)∈attacks$，且没有攻击 𝑏 的其他攻击者。

因此，给定一个论辩框架 𝐴𝐹 = ⟨𝐴𝑅, attacks⟩，通过映射，得到一个析取程序，记作 $P^{pr}_{Nieves}$ ，
其中上标 “𝑝𝑟” 用于指示优先语义，下标 “𝑁𝑖𝑒𝑣𝑒𝑠” 用于指示 Nieves 等人提出的方法。
该程序的回答集与原有论辩框架 𝐴𝐹 的优先外延一一对应，因为程序的每个回答集 𝐴𝑆 的补
是 𝐴𝐹 的一个优先外延。回答集 𝐴𝑆 的补定义如下：

$$
X(AS)=\{a\in AR, \text{def}(a)\notin AS\}
$$


#### 独立于论辩框架的映射法

Wakaki 等人提出的独立于论辩框架的方法[23]可以计算完全外延、稳定外延、优先外延和
基外延等。他们的映射方法依赖于**基于标记的论辩语义**描述方法。
给定一个论辩框架 𝐴𝐹 = ⟨𝐴𝑅, 𝑎𝑡𝑡𝑎𝑐𝑘 𝑠⟩，通过映射，一方面得到如下领域相关句集合 $P^{AF}_{Wakaki}$：

1. arg(𝑎) ←，对于每一个 𝑎 ∈ 𝐴𝑅；
2. att(𝑎, 𝑏) ←，对于每一个 (𝑎, 𝑏) ∈ 𝑎𝑡𝑡𝑎𝑐𝑘 𝑠。

另一方面，逻辑程序的其他句子与具体的论辩语义有关，而与论辩框架无关。
首先，在完全语义下，依据论证标记的约束，得到如下领域无关的句子集合：

1. in(𝑋) ← arg(𝑋), 𝑛𝑜𝑡 ng(𝑋).
    ng(𝑋) ← in(𝑌), att(𝑌, 𝑋).
    ng(𝑋) ← undec(𝑌), att(𝑌, 𝑋).
2. out(𝑋) ← in(𝑌), att(𝑌, 𝑋).
3. undec(𝑋) ← arg(𝑋), 𝑛𝑜𝑡 in(X), 𝑛𝑜𝑡 out(𝑋).

由上述两方面的句子组成一个逻辑程序 $P^{AF}_{Wakaki}$。
该程序的回答集与论辩框架 𝐴𝐹 的**完全外延**一一对应，这是因为 $P^{AF}_{Wakaki}$ 的每一个回答集 𝐴𝑆 中标记为 IN 的论证是𝐴𝐹的一个完全外延。𝐴𝑆中标记为IN的论证表示如下：

$$
I(AS)=\{a\in AF| in(a)\in AS\}
$$

给定论辩框架 𝐴𝐹 = ⟨𝐴𝑅, 𝑎𝑡𝑡𝑎𝑐𝑘 𝑠⟩ 和在完全语义下的逻辑程序 $P^{co}_{Wakaki}$，在稳定语义下，相应的逻辑程序为：

$$
P^{st}_{Wakaki} = P^{co}_{Wakaki}\cup \{undec(X)\}
$$

因此，与完全语义下的逻辑程序相比，在稳定语义下增加了一个约束：在稳定语义下一个论辩框架的所有论证均不能标记为“未确定的”。




