# Main memory

在计算机系统中，**内存碎片**通常分为两种类型：**内部碎片**和**外部碎片**。它们都与内存的分配和使用方式有关，但表现形式和影响不同。

## 碎片（fragment）

### 1. 内部碎片（Internal Fragmentation）

内部碎片指的是分配给程序或进程的内存块中的“浪费空间”。这种情况发生在内存分配的块大于实际需求时，导致一部分内存未被有效利用。

### 2. 外部碎片（External Fragmentation）
外部碎片是指内存中有多个不连续的空闲块，虽然空闲内存总量足够，但由于这些空闲块并不连续，导致无法分配给大的程序或数据。



## 页框（page frame）

- 页框是物理内存的基本分配单位。当操作系统从虚拟内存中请求某一页的内容时，它会将该虚拟页映射到一个物理页框中。

- 页框是物理内存的划分方式，与虚拟页相对应。操作系统通过页表将虚拟地址空间映射到这些物理页框。


## 页表（page table）

页表是操作系统中用于实现虚拟内存与物理内存映射的数据结构。它将虚拟地址空间中的虚拟页（Page）与物理地址空间中的物理页框（Page Frame）建立映射关系。现代系统中，页表通常采用多级结构（如二级页表、三级页表等）来减少内存开销。

### 页表项（Page Table Entry，PTE）

每一项通常包含虚拟页到物理页框的映射信息，可能还包含其他控制信息（如权限位、有效位等），具体为：
- 物理页框号（PFN）
- 有效位：有效位为 1 表示该条目有效且页面已经映射到物理内存中
- 权限位（读、写、执行权限等）：通过控制对内存页面的访问权限，实现内存隔离，防止非法访问
- 脏位：标记页面是否被修改。如果页面在内存中被修改过，脏位将被设置为 1。脏位的作用是告知操作系统，页面需要在从内存交换到磁盘时进行写回。
- 引用位：引用位用于表示页面是否在一定时间内被访问过。当页面被访问时，操作系统会将该位设置为 1。这有助于操作系统实现页面替换策略，例如 LRU（Least Recently Used） 替换策略。
- 用户/内核访问控制
- 缓存控制和页大小等




### TLB（Translation Lookaside Buffer）

TLB：硬件缓存，存储最近使用的虚拟页到物理页框的映射，以减少每次访问内存时对页表的查询，从而提高内存访问速度。

- 字段：包括页表条目中部分信息
  - 虚拟页号（VPN，Virtual Page Number）：虚拟地址的页号部分，用于查找页表的映射。
  - 物理页框号（PFN，Physical Frame Number）：虚拟页映射到的物理页框号。
  - 标志位：如有效位（valid bit）、权限位（如读/写权限）等。
  - 替换策略信息：如 LRU 计数等，用于决定哪个条目应当被替换。


### 内存共享

在多个进程之间共享内存时，多个虚拟地址空间可能映射到相同的物理内存页。例如，不同的进程可以通过映射相同的物理内存来共享数据，这样就可以实现进程间的高效数据交换。


### 分层页表（Hierarchical Page Tables）

1. 引入原因：在传统的单层页表（如 单级页表）中，虚拟地址空间的每一页都需要一个对应的物理页面地址，页表本身通常是一个巨大的数据结构，随着虚拟地址空间的增大，页表的大小也会急剧增加，这会导致存储和查找效率的下降。

为了解决这一问题，操作系统引入了 分层页表 结构，这样每个页表条目指向下一级页表，最终通过多级结构映射到物理内存。
2. 原理：

- 多级结构：将页表划分为多级（如两级、四级），虚拟地址分段用于各级索引。

示例（32位两级页表）：
- 虚拟地址分为：10位页目录索引 + 10位页表索引 + 12位页内偏移。
- 页目录（Page Directory）：1024项，每项指向一个页表（4KB）。
- 页表（Page Table）：1024项，每项指向物理页框（4KB页）。
- 按需分配：仅分配实际使用的页表，未使用的页目录项标记为无效，节省内存。

<img src="\img\study\cs\sys3\2-level-page.png">

### 哈希页表（Hashed page table）

- 通过使用哈希表来管理虚拟地址到物理地址的映射，特别适合于虚拟地址空间稀疏的场景。它能显著减少内存消耗并提高查找效率，尤其在大虚拟地址空间的情况下。然而，哈希冲突和内存管理的复杂性也可能影响其性能。

- 哈希页表的关键思想是利用哈希表的结构来存储页表项。在哈希页表中，虚拟地址的页号（VPN, Virtual Page Number）通过哈希函数映射到哈希表中的一个桶（bucket）。每个桶包含一个链表，链表中的每个元素存储一个虚拟页号与物理页号之间的映射。



## EAT（effective access time）


即**有效访问时间**，是衡量内存访问延迟的一个指标，尤其是在虚拟内存系统中，综合考虑了 **缓存命中率** 和 **页故障率** 等因素后，计算一次内存访问所需的平均时间。

有效访问时间通常是用来评估操作系统在内存管理中的性能，特别是在分页和虚拟内存环境下。它考虑了 **缓存访问**、**页表查询**、以及 **缺页中断**（**page fault**）等因素。

### EAT 的基本公式

有效访问时间（EAT）可以通过以下公式来计算：

\[
EAT = (1 - p) \times (T_{hit}) + p \times (T_{fault})
\]

其中：
- \( p \) 是 **页故障率**（Page Fault Rate），即访问的虚拟地址发生页故障的概率。
- \( T_{hit} \) 是 **缓存命中的时间**（Time to access memory when there is no page fault），即访问内存时，不发生页故障的时间（通常是对 TLB 或一级缓存的访问时间）。
- \( T_{fault} \) 是 **页故障时间**（Time to access memory when a page fault occurs），即发生页故障时的访问时间，包括查找页表、磁盘 I/O 等时间。



## 虚拟内存

### 按需分页（Demand Paging）

按需分页（Demand Paging）是一种虚拟内存管理技术，核心思想是**仅在程序实际需要访问某个页面时，才将其加载到物理内存中**，而非一次性加载全部页面。它通过延迟加载（Lazy Loading）优化内存使用，减少程序启动时间和物理内存占用，是操作系统高效管理内存的核心机制之一。


### **1. 工作原理**
#### **核心流程**
1. **初始状态**：
   - 程序的可执行文件存储在磁盘（如二进制文件），但**仅加载必要部分到内存**（如代码段头部）。
   - 页表中大部分页表项的**存在位（Present Bit）**标记为`0`（表示页面不在内存中）。

2. **访问未加载的页面**：
   - 当程序访问一个标记为“不在内存”的页面时，触发**缺页异常（Page Fault）**。
   - 操作系统接管处理流程：
     - 从磁盘（或交换空间）加载所需页面到物理内存。
     - 更新页表项的存在位和物理页框号。
     - 恢复程序执行，重新执行引发缺页的指令。

3. **动态管理**：
   - 若物理内存不足，操作系统通过**页面置换算法**（如LRU、FIFO）淘汰旧页面，腾出空间。

---

### **2. 具体示例**
假设一个程序访问虚拟地址 `0x08048000`，其映射的物理页面尚未加载到内存。

#### **步骤分解**
1. **触发缺页异常**：
   - CPU访问虚拟地址 `0x08048000`，页表项存在位为`0`。
   - 硬件触发缺页异常，切换到内核模式。

2. **操作系统处理缺页**：
   - **查询页表项**：确定该虚拟地址对应的磁盘位置（如可执行文件中的偏移）。
   - **分配物理页框**：选择一个空闲页框（如物理地址 `0x0000A000`）。
   - **加载页面**：将磁盘中 `0x08048000` 对应的数据（如代码或数据段）复制到物理页框 `0x0000A000`。
   - **更新页表**：
     - 设置页表项的存在位为`1`，物理页框号为 `0x0000A`（高20位）。
     - 更新标志位（如可读写权限）。

3. **恢复程序执行**：
   - CPU重新执行触发缺页的指令，此时页表项已有效，正常完成地址转换。

---

### **3. 关键数据结构**
#### **页表项（PTE）标志位**
- **存在位（Present Bit）**：1表示页面在内存，0表示在磁盘。
- **修改位（Dirty Bit）**：1表示页面被修改过，淘汰时需写回磁盘。
- **访问位（Accessed Bit）**：记录页面是否被访问，用于页面置换算法。

#### **缺页异常处理流程**
- **硬件触发**：CPU检测到存在位为`0`，保存现场并跳转到内核缺页处理程序。
- **软件处理**：操作系统通过虚拟地址和页表定位磁盘数据，完成加载。

---

### **4. 优点与缺点**

| **优点**                          | **缺点**                          |
|-----------------------------------|-----------------------------------|
| 减少内存占用（仅加载必要页面）     | 缺页处理引入延迟（需磁盘I/O）     |
| 加速程序启动（无需加载全部代码）   | 频繁缺页导致抖动（Thrashing）      |
| 支持运行大于物理内存的程序         | 需高效置换算法避免性能下降         |



### **性能优化**
- **预取（Prefetching）**：预测即将访问的页面并提前加载（如程序启动时预读代码段）。
- **TLB（快表）**：缓存常用页表项，减少地址转换开销。
- **写时复制（Copy-on-Write）**：延迟页面复制，直到真正修改时触发缺页（用于`fork()`创建子进程）。

### 写时复制（copy on write）

写时复制（Copy-on-Write, CoW）是一种内存管理优化技术，核心思想是多个进程共享同一份物理内存页，直到某个进程尝试修改该页时，才真正复制该页并分配新的物理内存。通过延迟复制的策略，CoW显著减少了内存冗余和进程创建的开销，广泛应用于操作系统的进程创建（如fork()）和内存共享场景。

核心流程
- 共享初始状态：

父进程与子进程共享所有物理内存页，页表项标记为只读（即使原页可写）。

共享页的引用计数（Reference Count）增加，表示多个进程正在使用。

- 触发写操作：

当任一进程（父或子）尝试写入共享页时，触发缺页异常（因页表项为只读）。

- 操作系统接管处理流程：

检查该页是否为CoW页（通过标志位或元数据）。

复制物理页，为写入进程分配新物理页，更新其页表项为可写。

原共享页的引用计数减1，若为0则释放。

- 后续访问：

修改后的进程使用独立副本，原进程继续共享未修改的页。


### 内存交换分区（swap space）

内存交换分区（Swap Space）是操作系统用于扩展物理内存（RAM）的一种机制。它通过将部分内存数据临时存储到硬盘上的专用区域（称为交换分区或交换文件），来缓解物理内存不足的问题，确保系统在内存资源紧张时仍能稳定运行。



### **核心作用**
1. **扩展可用内存**  
   当物理内存不足时，操作系统将暂时不活跃的内存页（内存数据单元）移动到交换分区，腾出物理内存供急需的程序使用。
2. **支持休眠（Hibernate）**  
   休眠时，系统会将内存的完整内容写入交换分区，以便恢复时快速加载。
3. **防止内存耗尽（OOM）**  
   避免因内存不足直接触发内核的“Out-of-Memory Killer”强制终止进程。

---

### **工作原理**
1. **页面置换（Paging）**  
   内核通过算法（如LRU，最近最少使用）选择不活跃的内存页，将其写入交换分区，并标记原物理内存区域为可重用。
2. **按需换入（Swap-in）**  
   当程序访问已被换出的页面时，系统将其从交换分区重新加载到物理内存（可能触发磁盘I/O延迟）。

---


### **典型使用场景**
1. **物理内存不足**  
   当程序申请的内存超过物理RAM容量时，系统自动使用交换空间。
2. **处理内存峰值**  
   即使物理内存充足，交换空间可应对突发性内存需求高峰。
3. **长期空闲进程**  
   后台进程的内存可能被换出，释放物理内存给活跃进程。

---

### **配置建议**
1. **交换空间大小**  
   - **传统建议**：物理内存的1~2倍（适用于小内存机器，如4GB以下）。  
   - **现代系统**：若内存充足（如16GB+），交换空间可设为1~2GB，主要用于休眠支持或应急。  
   - **服务器场景**：若禁用休眠，可配置少量交换空间（如1GB）以应对突发负载。
2. **优先级设置（Linux）**  
   多个交换分区/文件可设置不同优先级（`pri=N`），系统优先使用高优先级区域。

---

### **优缺点对比**

| **优点**                          | **缺点**                              |
|-----------------------------------|---------------------------------------|
| 防止内存耗尽导致系统崩溃          | 硬盘速度远慢于内存（机械硬盘尤甚）    |
| 允许运行更多或更大的程序          | 频繁交换（Swapping）会显著降低性能    |
| 支持休眠功能                      | 固态硬盘（SSD）频繁写入可能缩短寿命   |


## 页替换（Page replacement）


**页替换（Page Replacement）** 是操作系统内存管理中的核心机制，用于在物理内存不足时，选择合适的页面（Page）从内存换出到交换空间（Swap Space），以腾出空间加载新页面。其目标是尽可能减少因缺页中断（Page Fault）导致的性能损失，同时保证系统稳定运行。

- **为什么需要页替换？**
  1. **物理内存有限**：当进程申请的内存超过物理内存容量时，需通过换出非活跃页面来腾出空间。
  2. **虚拟内存支持**：虚拟内存机制允许进程使用比物理内存更大的地址空间，依赖页替换实现动态映射。
  3. **多任务优化**：通过换出后台进程的页面，优先为活跃进程分配内存。

---

### **页替换算法**
以下是常见的页替换算法及其特点：

| **算法**               | **描述**                                                                 | **优点**                          | **缺点**                           |
|------------------------|-------------------------------------------------------------------------|-----------------------------------|------------------------------------|
| **最优置换（OPT）**     | 换出未来最长时间不再被访问的页面（理论最优）                             | 命中率最高（理想情况）            | 无法实现（需预知未来访问顺序）            |
| **先进先出（FIFO）**   | 换出最早进入内存的页面                                                   | 实现简单                          | 可能淘汰高频访问页面（Belady异常）        |
| **最近最少使用（LRU）**| 换出最长时间未被访问的页面                                               | 接近OPT的实际效果                 | 实现复杂（需维护访问时间戳或链表）        |
| **时钟算法（Clock）**  | 环形链表模拟LRU，通过“使用位”标记页面是否被访问                           | 低开销，近似LRU                   | 命中率略低于LRU                           |
| **最不常用（LFU）**    | 换出访问频率最低的页面                                                   | 适合访问模式稳定的场景            | 对突发访问敏感，需维护计数器              |
| **工作集算法（WS）**   | 基于局部性原理，保留进程当前工作集内的页面                               | 符合程序运行规律                  | 需动态跟踪工作集，开销较大                |

---

### **算法对比示例**
假设页面访问序列为：`1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5`，物理内存容量为3页：

#### **FIFO**

| 访问序列 | 1 | 2 | 3 | 4 | 1 | 2 | 5 | 1 | 2 | 3 | 4 | 5 |
|----------|---|---|---|---|---|---|---|---|---|---|---|---|
| 内存状态 | 1 | 1 | 1 | **4** | 4 | 4 | **5** | 5 | 5 | **3** | **4** | 4 |
| 缺页     | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ |  

**缺页次数**：9次（Belady异常明显：淘汰后面就要访问的页面）

Belady异常可能会导致页数越多时，发生page faults的次数却不会越少。

#### **LRU**

| 访问序列 | 1 | 2 | 3 | 4 | 1 | 2 | 5 | 1 | 2 | 3 | 4 | 5 |
|----------|---|---|---|---|---|---|---|---|---|---|---|---|
| 内存状态 | 1 | 1 | 1 | **4** | 4 | 4 | **5** | 5 | 5 | **3** | **4** | 4 |
| 缺页     | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ | ✔ |  
**缺页次数**：8次（优于FIFO）

#### **Clock算法**
通过环形链表和“使用位”标记，定期清除使用位，优先淘汰未被访问的页面。命中率接近LRU，但实现更高效。

---

### **实际系统中的页替换（以Linux为例）**
1. **双链表策略**：  
   Linux使用`active_list`和`inactive_list`两个链表，基于页面活跃性管理：  
   - 页面首次载入时进入`active_list`。  
   - 定期扫描将不活跃页面移至`inactive_list`。  
   - 缺页时优先从`inactive_list`淘汰页面。  

2. **交换倾向（Swappiness）**：  
   通过`/proc/sys/vm/swappiness`（默认值60）控制内核换出页面的积极性：  
   - 值越高，越倾向于换出页面。  
   - 值设为0时，尽量保留物理内存（除非内存耗尽）。  

3. **LRU近似实现**：  
   使用“第二次机会”策略（类似Clock算法），结合页面访问标志位（`PG_referenced`）动态调整活跃性。

---

### **页替换的性能影响**
1. **缺页中断开销**：  
   - **硬缺页（Hard Fault）**：需从磁盘加载页面，延迟高（ms级）。  
   - **软缺页（Soft Fault）**：页面仍在内存中（如共享库），延迟低（μs级）。  

2. **交换抖动（Thrashing）**：  
   当频繁换入/换出页面时，系统时间主要消耗在I/O操作上，导致性能急剧下降。  
   **解决方案**：  
   - 增加物理内存。  
   - 调整进程优先级或限制内存使用（如`cgroups`）。  
   - 优化程序的内存访问模式（减少随机访问）。




